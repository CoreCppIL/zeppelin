-
  id: 011
  title: "Understanding and Mastering C++ Complexity"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>C++ is a very broad language, making it quite natural to have knowledge gaps. Some knowledge gaps are a result of the many additions
    that come with the new versions of C++, but not necessarily, some knowledge gaps may stretch back to C++98.</p>
    <p><b>The goal of this workshop is to cover C++ topics for the intermediate level C++ programmer (with around 1-4 years of experience in C++).</b>
    We would focus on C++ parts that allow you to write better code, more efficient and more efficiently. The workshop would also go through
    important parts of modern C++, from C++11 up to C++20, assuring attendees that mastering C++ is doable.</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/4inywgn7kqq">register now</a>!</p>
  subtype: workshop
  speakers: [20]
  language: he
-
  id: 012
  title: "Linux Security and Isolation APIs essentials"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>This course provides an overview of the low-level Linux features–set-UID programs, capabilities, namespaces, and control groups (v2)–that are used
    to implement privileged applications and build container, virtualization, and sandboxing technologies. (The course does not cover systems such as
    Docker and LXC, but participants will gain an an insight into the implementation and operation of such systems.)</p>
    <p>The primary audience comprises designers and programmers building privileged applications, container applications, and sandboxing applications.
    Systems administrators who manage such applications will also find the course of benefit. Participants should have some awareness of classical
    Linux/UNIX concepts such as file descriptors and file I/O, signals, and the process lifecycle (fork(), exec(), wait(), exit()). In addition,
    participants should have a reading knowledge of the C programming language. (Note, however, that the course exercises do not require writing any programs.)</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/6t7udu7msda">register now</a>!</p>
  subtype: workshop
  speakers: [21]
  language: en
-
  id: 013
  title: "Building a compiler (almost) from scratch"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>Have you always treated a compiler as magical? Do you want to understand how the compiler actually works? How it transforms code into machine language?
    This tutorial day is a condensed one day course in creating compilers. Well discuss how we parse the code, turn it into semantic constructs, and use those
    to generate actual executable binary. We'll also touch more advanced subjects, such as optimizations and ambiguity. Some of the course will be going over
    the code of an existing (relatively simple) compiler. We'll also discuss tools that help generate compilers and their limitations. You may not be able to
    immediately write your own compiler upon completion, but the tutorial _will_ demystify compiler to the point you will be able to understand how they work.</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/ozmkotlgeqi">register now</a>!</p>
  subtype: workshop
  speakers: [22]
  language: en
-
  id: 014
  title: "Accelerated Modern C++ Tour"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>The following hands on tutorial provides a tour of the core modern C++ programming language ideas and core idioms. Many features and examples of the
    language will be shown in an 'accelerated manner', covering the most important features that every C++ programmer should know. Folks who should attend
    this tutorial are those who lack Modern C++ knowledge, or otherwise want a day to reinforce their fundamentals in C++. This will be a hands on workshop
    in which learners will be introduced to each new language feature and as each feature is learned, learners will build from scratch a final project to
    reinforce their knowledge.</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/eajrgx1c2tm">register now</a>!</p>
  subtype: workshop
  speakers: [23]
  language: en
-
  id: 015
  title: "C++ Templates for Developers"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>As an intermediate-level C++ programmer, you already know about and have very likely used one or more kinds of C++ templates in your code. Whether you’ve
    applied std::vector or std::array to your work, or called upon any of the multitude of algorithms that the standard library provides, you’ve experienced some
    of the power that templates add to a C++ programmer’s toolkit.</p>
    <p>This Workshop will help you take your knowledge and experience to the next level, so that you will both (1) understand exactly how C++ templates are
    handled by a compiler, and (2) be able to take advantage of that knowledge to create templates that are tailored to your own programming needs.</p>
    <p>In this Academy Workshop, we will explore all significant facets of the many kinds of C++ templates (and other templated entities), and will do so
    in as much depth as our time together will permit. The Workshop will include presentations as well as optional (but recommended) practice exercises,
    together with numerous examples and tips that you can learn from and apply. Many of our examples and exercises will be taken from the standard library,
    thus doubling the useful information you’ll glean from your participation.</p>
    <p>Come discover how the world of C++ templates will open to you once you’ve mastered a modest handful of straightforward, key insights and principles.
    Whether it’s programming generically, or with variadics, SFINAE, concepts, overloading, or other coding practices, this Workshop will allow you to
    explore and apply template-based techniques that will help solve problems in your programming domain!</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/one2l1ro2me">register now</a>!</p>
  subtype: workshop
  speakers: [10]
  language: en
-
  id: 016
  title: "C++17: All You Need To Know"
  description: >
    <p><b>WORKSHOP</b></p>
    <p>If you've caught up with C++11 and C++14, but did not yet have a chance to deeply explore what C++17 has to offer, then this course is for you!</p>
    <p>We will cover the most important additions in C++17, enabling you to write idiomatic code using major new features such as: CTAD, structured bindings,
    fold expressions, and mandatory copy elision.</p>
    <p>Both the core language and the library have been extended with new features that significantly reduce the likelihood of bugs, improve readability
    and maintainability of code, and enable new powerful programming paradigms.</p>
    <p>Throughout lectures, quizzes, and real-life usage examples, you will understand the value C++17 brings to the table, and you will immediately be able
    to apply the lessons learned to your real projects.</p>
    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/adu0svo6cew">register now</a>!</p>
  subtype: workshop
  speakers: [24]
  language: en
-
  id: 020
  title: "Keynote :: Rust Features that I Want in C++"
  description: >
    <p>By many accounts, Rust is one of the fastest growing programming languages out there. While there are many factors fueling
    this growth, this talk will focus on the aspects of Rust that make it particularly attractive as a systems programming language.
    This covers tooling, community, strategy, and, of course, features. Throughout the talk we'll be revisiting the question,
    "Can we have this in C++ and, if so, how can we get it?" While we'll examine the practicalities of the ISO process and
    the limitations of backwards compatibility, there is a lot of optimism to be had.</p>
    <p>This talk assumes an intermediate level of C++ know-how and no prior knowledge of Rust.</p>
  subtype: keynote
  speakers: [11]
  language: en
-
  id: 201
  title: "C++ Standard Parallelism"
  description: >
    <p>Imagine writing parallel code that can run on any platform - CPUs, GPUs, DPUs, specialized accelerators, etc - without any language
    or vendor extensions, external libraries, or special compilation tools. It's no longer just a dream - you can do it today in Standard C++!</p>
    <p>Parallelism is increasingly common in software, from supercomputer simulations to mobile applications. But writing parallel code is
    increasingly challenging, due to an explosion of diversity in hardware, a trend that's likely to continue into the future.
    To meet this challenge, the C++ Committee has developed C++ Standard Parallelism, a parallel programming model for Standard C++ that is
    portable to all platforms, from your smartwatch to your supercomputer, and delivers reasonable performance and efficiency for most use cases.</p>
    <p>Our vision of C++ Standard Parallelism consists of three key components:</p>
    <ul>
       <li>Common parallel algorithms that dispatch to vendor-optimized parallel libraries.</li>
       <li>Tools to write your own parallel algorithms that run anywhere.</li>
       <li>Mechanisms for composing parallel invocations of algorithms into task graphs.</li>
    </ul>
    <p>In this talk, we'll dive into the roadmap for C++ Standard Parallelism - we'll discuss what we already have that you can use today,
    what's coming down the line, and where the future may lead us.</p>
  speakers: [101]
  language: en
-
  id: 202
  title: "Deciphering Coroutines - A Visual Approach"
  description: >
    <p>Coroutines are a powerful addition to C++20, allowing developers to drastically simplify code for certain kinds of problems and be adapted to
    a wide range of different use cases. But anyone trying to familiarize themselves with them will quickly notice that this flexibility comes at a price:
    In their current state, C++ coroutines are notoriously difficult to learn and their tight integration with the compiler gives them a feel quite
    unlike any other feature in the language.</p>
    <p>The goal of this talk is to give a sustainable introduction on how to read and reason about coroutine code. We will learn how all the different
    elements of the mechanism fit together and to distinguish the parts of the code that follow the new rules of coroutines from those that still follow
    the well known conventional rules of C++. We will approach this through the construction of a coroutine cheat sheet, a collection of diagrams that
    serve as visual maps for navigating the complexities of the feature. Special care is taken to provide visual cues that are easily recognizable later on,
    to compensate for the fact that learners tend to forget the numerous details of the mechanism very fast if they don't use it in their everyday coding.</p>
    <p>To account for the complexity of the topic, this talk focuses exclusively on providing a comprehensive introduction to the coroutine syntax,
    without discussing any advanced use cases. However, with the knowledge obtained from this talk, attendees will be able to easily follow more advanced
    presentations of coroutines later on without getting lost in the technical details of its peculiar syntax.</p>
  speakers: [102]
  language: en
-
  id: 203
  title: "What You Can Learn From Being Too Cute (Part 2 of N)"
  description: >
    <p>During the COVID-19 global pandemic, as we all searched for ways to stay connected to the C++ community, I innocently started posting short,
    25-line or less C++ snippets of counterintuitive C++ code that I called my "Cute C++ trick of the day." The amount of attention these tricks got
    was surprising, and as I've posted more of them, I've realized that these counterintuitive snippets of C++ code offer pithy and memorable ways
    to teach people some intermediate or advanced aspects of C++ (that often come up in real code!).</p>
    <p>I gave part 1 (of N) of this talk at CppCon 2021, and this is part 2 (of N). In this presentation, I will dissect a few more of my most
    popular "Cute C++ tricks" to a level of detail not possible on social media platforms like Twitter. I'll talk about how and why these tricks
    work the way they do, talk about the dark corners of C++ they touch upon, and talk about what you should actually do if you need to produce
    the same effect in production code. While not targeted at beginners, these tricks span the gauntlet from features that most intermediate
    programmers are aware of (but never thought to use in a particular way) to dark corners of the language that many of my C++ committee colleagues
    were surprised to learn about. Throughout it all runs a common thread: learning how to exploit your own curiosity to expand your toolbox, gain a
    better grasp of the fundamentals of C++, and ultimately, become a better programmer.</p>
  speakers: [103]
  language: en
-
  id: 209
  title: "Customization Methods: Connecting User And Library Code"
  description: >
    <p>The interface between a library and its users is a major design consideration for every developer, and has been evolving greatly over
    C++’s lifetime. In this talk we will go over different methods for connecting generic library code with user-side specific code, commonly
    known as Customization Points. We will cover the benefits and downsides of different methods (including CTS, ADL, Concepts, CTOs, and the
    latest to be considered - tag_invoke), and present future directions for these mechanisms.</p>
    <p>At the end of the talk, you’ll be familiar with the terminology and developments in this field, including the ones planned for C++23 and C++26.</p>
  speakers: [109]
  language: en
-
  id: 216
  title: "Coroutine Intuition"
  description: >
    <p>As one of the 'big four' new additions to C++20, coroutines allow us to rethink how we design and architect our functions, systems and code.</p>
    <p>With no initial support in the STL, many of us are still hesitant to embrace coroutines and consider how to effectively use them to improve the
    readability, maintainability and composability of our creations.</p>
    <p>In this talk, I'll explore and explain topics like <i>stackless</i>, <i>cooperative asyncrony</i>, <i>generators</i> and <i>senders/receivers</i>. Through many concise and
    different examples of coroutine usage, we'll gain intuition on which types of problems can elegantly be solved with coroutines, and how such solutions
    can lead to cleaner, safer code.</p>
  speakers: [116]
  language: en
-
  id: 204
  title: "Programming for Every Language, Everywhere, All at Once"
  description: >
    <p>What do you do when you want to write a library for multiple languages? You can always implement the library multiple times in each language,
    but there is a better option. In this talk we'll discuss how to write logic in a low-level language and access it from multiple high level managed languages.
    We'll try to make foreign function interfaces sound not so foreign, become comfortable with calling conventions, and share the joys and sorrows of shared memory.</p>
  speakers: [104]
  language: en
-
  id: 199
  title: "Pragmatic Simplicity: Actionable Guidelines To Tame Complexity"
  description: >
    <p>Minimizing complexity in a codebase provides invaluable benefits, especially at scale, including but not limited to: maintainability,
    ease of understanding, malleability, debuggability, and testability. Such benefits translate not only into real economical advantages,
    but also increase the mental well-being of any developer.</p>
    <p>So, how can "simplicity" be achieved?</p>
    <p>Rather than focusing on philosophical concepts, this interactive presentation will give developers pragmatic and actionable guidelines
    that can be readily applied to reduce complexity in any codebase. Starting from a wide variety of examples (e.g. casting, containers, looping, attributes)
    a set of precepts will be derived together with the audience. After that, a deep analysis of where those precepts fall short will be given, honing them
    until reaching the final goal of obtaining actionable guidelines useful in the real world will be reached.</p>
    <p>If any of the following questions sound interesting to you, then you will definitely find this talk helpful and enjoyable:</p>
    <ul>
       <li>Should <code>emplace_back</code> always be used instead of <code>push_back?</code></li>
       <li>Does <code>[[nodiscard]]</code> belong on every pure function returning non-<code>void</code>?</li>
       <li>How can one decide between using open-set and closed-set polymorphism?</li>
       <li>Are regular <code>for</code> loops the best way of iterating over a range of numbers?</li>
       <li>Do C-style casts still have a place in Modern C++?</li>
       <li>Is <code>T*</code> really a valid replacement for <code>std::optional<T&></code>?</li>
       <li>Does simple code imply concise code?</li>
       <li>Can using templates reduce the complexity of a code base?</li>
       <li>When does it make most sense to use type deduction?</li>
    </ul>
  speakers: [24]
  language: en
-
  id: 205
  title: "Generative C++"
  description: >
    <p>Currently, there are two main ways to generate code in C++ - templates and macros. While macros can manipulate text, they lack the
    compile time information and constraints that the compiler provides. Templates on the other hand are incredibly powerful especially with C++20’s
    concepts, non type template parameters and increased constexpr support, however, while they work great with types and compile time constants they
    can't be used with identifiers, keywords and other C++ syntax elements. The metaclasses proposal by Herb Sutter aims to give more powerful code generation tools,
    but it is not part of the standard yet. We will also compare these features to code generation features in other languages. So what can we do right now in
    C++ in terms of generative code? Well... the answer is anything we want.</p>
    <p>In this talk, we will go over a different approach for compile time code generation that can be used right now with C++ 20. We will use it to implement
    the examples from Herb Sutter's metaclasses talk, generate consistent C++ and vulkan shader code, and extend it to support arbitrary compile time execution
    (yes, it can even run minecraft).</p>
    <p>We will cover key compile time development topics: 1. What are the pros and cons of the possible compile time input validation methods
    (static assert, constexpr throw, concepts) and which one should you choose for your compile time library. 2. Working in constexpr context and easily converting
    between dynamic containers (vector, string) and static containers (array). 3. Designing expressive APIs with non type template parameters.</p>
    <p>To achieve our goal of code generation we will also dive into some less known topics like the behavior of std::source_location in templates,
    compile time printing of constexpr strings, DLL injection, function hooks and some pitfalls of C++20's modules build process and how to avoid them.</p>
    <p>In the end you will have all the tools to create your own compile time code generation library or just download the library with the examples from GitHub and use it.</p>
  speakers: [105]
  language: en
-
  id: 206
  title: "Binary Object Serialization with Complex Traversal & Reconstruction"
  description: >
    <p>This talk will describe a minimally intrusive technique to add serialization to a set of classes, traversing the hierarchical data, persisting in a binary
    format and dynamic reconstruction.</p>
    <p>When storing, it can deduce the data types using Template Argument Deduction (TAD).</p>
    <p>When loading, it uses a homebrew reflection technique for dynamic object creation. Reflection as a language feature will be unavailable until at least C++26.
    This serialization technique can dynamically recreate a persisted complex data structure/structure network. This is a platform agnostic technique.
    Not everybody is yet able to migrate to C++20, so this is using a C++14 compliant SFINAE/std::enable_if&lt;&gt; mechanism. We will also explore optimizations
    and what it takes to convert this technique to use C++20 concepts.</p>
    <p>This is not trying to sell you on the use of my library but metaprogramming techniques you can add to your toolbox.</p>
  speakers: [106]
  language: en
-
  id: 207
  title: "Atomic Variables: Not radioactive, but you probably still don't want to touch them!"
  description: >
    <p>Different hardware architectures implement different memory models. This in turn makes porting software between different targets an insanely
    complicated task. To solve this problem, C++11 introduced a language memory model that was later adopted by other languages such as D and Rust.
    In this talk, we will discuss the problem, the solution and why you still have to be careful if you want to maximize performance. In order to try
    and alleviate the complexity, we will also consider a new technique to make reasoning easier by relying on sequential consistency. This talk will
    be based on two recent research papers published in PLDI'19 and POPL'21.</p>
  speakers: [107]
  language: en
-
  id: 208
  title: "A Practical Approach to Error Handling"
  description: >
    <p>Every program may encounter errors, some originating from internal bugs in the program, others coming from the environment the program is operating in.
    Ignoring all errors will make the program utterly unreliable, while treating every conceivable one introduces lots of extra complexity with little benefit.
    At think-cell, we have been using and refining our own principled approach to error handling, which we have not seen elsewhere. This talk describes our method,
    so that in your next project you can write more reliable software with less effort.</p>
  speakers: [108]
  language: en
-
  id: 218
  title: "Personal Log: Where No Init Has Gone Before"
  description: >
    <p>Can your code have logging entries whose sensitive messages don't show up in the shipped binaries? And can the following code snippet ever work?
    </p><pre><code>static bool initially_false = false;</br>void no_one_calls_me() { DO_ON_INIT(initially_false = true); }</br>int main() {</br>   assert(initially_false == true);</br>   return 0;</br>}</code></pre>
    <p>Well yes, this is actual working C++17 code! And yes, we can use this tool to produce a logger with vanishing strings!</p>
    <p>As part of this talk we will go behind the scenes of the DO_ON_INIT utility, the process involved in developing the idea and its surprisingly simple
    implementation details (under 20 lines of C++17 code, and even less in C++20).</p>
    <p>We shall also see how this utility is instrumental in making possible the no-strings-attached logger and its associated automatically-generated decoding facility.
    We will implement a simple obfuscation technique which replaces logged strings with hashes at compile-time, to avoid shipping binaries containing sensitive
    textual giveaways. To decode such logs (in a separate decoder utility) we shall use DO_ON_INIT to automatically collect and register all the logged strings
    system-wide, along with their hashes, without requiring any additional tool (such as an in-house pre-processor).</p>
    <p>This is yet another example of emergent behavior in C++, consisting of unrelated language features being put to use together in a novel and unexpected way.
    Could your idea be next?</p>
  speakers: [118]
  language: en
-
  id: 219
  title: "Windows, macOS and the Web: Lessons from cross-platform development at think-cell"
  description: >
    <p>For twelve years, think-cell had been a Windows-only software company and our codebase of approximately 700k lines of code had accumulated many unintentional
    platform dependencies. Six years ago, we decided to port our application to the Mac. This change has affected every part of our development process:
    the project organization, build system and the way we program in C++ today. The commonly used cross-platform libraries such as Qt and boost were good
    tools to build on, but by themselves were not enough. For many concepts, such as mutexes, semaphores or shared memory, they only offer a common interface
    to platform-specific objects with very different semantics and lifetimes. We wanted light-weight, platform-independent C++ abstractions with identical
    semantics for rendering, internationalization, file I/O, mouse event handling, RPC calls and error reporting. Developing these was challenging, firstly,
    because we had to define which semantics our application needed and, secondly, we had to implement them on each platform. This was not an easy process
    but I would argue it has improved the quality of our code very much. By now, we have moved on to the next challenge and have started to move some functionality
    to web applications. We wanted to reuse our existing code-base of course, and that meant writing web applications in expressive, type-safe C++.
    Definitely an advantage in our book! We have built our web applications using emscripten, but we generate type-safe C++ bindings from any TypeScript interface
    definition. In my talk, I will give you an overview of the C++ abstractions we have implemented, focusing on the cross-platform problem areas where common semantics
    were hard to define due to limitations of either one of the operating systems, and of course I will show you our tools that let us write web application in C++.</p>
  speakers: [119]
  language: en
-
  id: 220
  title: "All you wanted to know and more on C++20 spaceship operator"
  description: >
    <p>C++20 simplifies the definition of comparisons for user-defined types and introduces better ways to deal with them. For this purpose, the new operator
    <code><=></code> (also called the spaceship operator) was introduced.</p>
    <p>It is more complicated than it may seem. In this talk we will go thru how to use legacy code with this new feature, intresting bugs that may appear,
    how to use this operator with generic programming and a discussion of weak, strong and partial ordering.</p>
  speakers: [120]
  language: en
-
  id: 221
  title: "From Templates to Concepts"
  description: >
    <p>Metaprogramming is been with us since C++98 but as the language evolves we have more tools and the code get simpler and clearer. In this talk we will
    cover the history of Templates and how the usage and readability became clearer and simpler with each standard. We will develop a concept with c++11-c++17
    for checking if a type is container and then we will discover how c++20 concepts make the whole thing much easier.</p>
  speakers: [121]
  language: en
-
  id: 217
  title: "Const Correctness: How To Be Const Correct And Amazing At It"
  description: >
    <p>The <code>const</code> keyword is fundamental in C++ and an awesome tool in your toolbox. I will show you how to use const simply and correctly, how to introduce
    it to an existing code base, the important guarantees it provides (as well as what it does not), and much more. Additionally you'll learn how to use the mutable
    keyword correctly, work well with threading, learn experimental features, and be safer at programming.</p>
  speakers: [117]
  language: en
-
  id: 222
  title: "SYCL: the future is open, parallel and heterogenous"
  description: >
    <p>oneAPI industry initiative is taking C++ to a heterogeneous and parallel computing future with SYCL. SYCL takes programmers out of proprietary
    languages to an open-source open-vendor cross device world. Understand the motivation and the vision behind SYCL, learn and see demos of the basics
    of SYCL to get started. And hear success stories from companies, universities and national labs who are already using SYCL.</p>
  speakers: [122,130]
  language: en
-
  id: 223
  title: "C++20 Likely and Unlikely: A Journey Through Branch Prediction and Compiler Optimizations"
  description: >
    <p>C++20 added the <code>[[likely]]</code> and <code>[[unlikely]]</code> attributes, which already had compiler intrinsics before.
    How likely is using these attributes would affect our code performance?</p>
    <p>In this talk we travel through branch prediction, optimizations and pessimizations, and the art of benchmarking. We will see that in C++
    questions that seem simple to begin with do not get a simple answer, but an interesting one!</p>
    <p>The talk will allow participants to better identify points for performance improvement, and focus their efforts in the right direction.</p>
  speakers: [123]
  language: en
-
  id: 224
  title: "Serialization In Modern C++"
  description: >
    <p>Whether you're writing a web application, kernel module, or real time OS, you'll find yourself serializing and deserializng pieces of data from your code.</p>
    <p>We will survey possible approaches to serialize C++ stucts.</p>
  speakers: [124]
  language: en
-
  id: 211
  title: "Introduction to oneDnn - Intel’s oneAPI deep neural network Library"
  description: >
    <p>Deep learning domain is continuously changing and evolving. New workloads and use cases frequently appear, implying new requirements to
    HW and SW vendors in the deep learning market. oneDnn is Intel’s open-source cross-platform performance library of basic building blocks
    for deep learning applications. This talk will introduce oneDnn library, its programming model, primitives, and usage.</p>
  speakers: [111]
  language: en
-
  id: 210
  title: "coroutines in production code, what we've learned"
  description: >
    <p>Sharing what we had learned while adopting coroutines for several production components. files I/O, and networking. while comparing to the alternatives.</p>
  speakers: [110]
  language: he
-
  id: 213
  title: "Observability Tools: Quickly gather insight in the behavior of your program"
  description: >
    <p>Going beyond GDB and printf! We present a few observability tools to help you understand what your program is doing and where it is spending time.</p>
    <p>A must hear for all developers working with Linux and Open Source!</p>
  speakers: [113]
  language: en
-
  id: 212
  title: "Multi-methods in C++"
  description: >
    <p>Multi-methods are functions that are polymorphic with regard to more than one parameter (while the regular virtual functions we have in the
    language are polymorphic with regard to only one parameter, the object they are invoked on). Multi-methods are useful in several use-cases,
    and discussed by Scott Meyers (More Effective C++, Item 31) and more. In this talk we will go over multiple approaches for implementing multi-methods
    in C++ and see how new and planned C++ features might improve the situation</p>
  speakers: [112]
  language: en
-
  id: 225
  title: "How C++23 changes the way we write code"
  description: >
    <p>C++20 was a huge release: coroutines, concepts, ranges, and modules profoundly changed the way we write code and think about C++.
    In comparison, C++23 is a lot smaller in scope: its primary mission is to complete C++20, to fill holes, and to fix issues.
    Nevertheless, some great new features made the cut this time around, both in the standard library and in the core language. This is even
    more remarkable considering that the entire feature design phase of C++23 took place during the COVID-19 pandemic, challenging the ISO C++
    committee to completely reinvent how we work together.</p>
    <p>This is not a firehose talk about C++23 that tries to cram as many additions and improvements as possible into one hour. Instead,
    we deliberately focus on just a handful of new features that are going to noticeably change and improve the experience of the everyday
    C++ programmer. We will talk about how std::expected improves error handling, the huge impact that std::mdspan will have on scientific computing,
    how deducing <code>this</code> greatly simplifies longstanding C++ idioms such as CRTP, and how <code>std::print</code> will forever change how we write "Hello, World".</p>
  speakers: [125]
  language: en
-
  id: 214
  title: "Considerations when Working with Shared Pointers"
  description: >
    <p>I will present some important caveats when working with shared pointers: performance, memory efficiency, and design considerations.</p>
  speakers: [114]
  language: en
-
  id: 226
  title: "Introduction to Google Test and Google Mock"
  description: >
    <p>Google Test and Google Mock are two unit-testing libraries that I've been using for several years now. This talk will cover the basics
    of using these libraries and will highlight what I consider to be the most interesting advanced features.</p>
  speakers: [126]
  language: en
-
  id: 227
  title: "Back to basics: lambda expressions"
  description: >
    <p>The lecture will expose the evolution of lambda expression from C++11 through C++23. We will cover using IIFE, recursive lambdas, currying and more lambda calculus brain candies.</p>
  speakers: [127]
  language: en
-
  id: 228
  title: "Reproducible Developer Environments"
  description: >
    <p>Getting a developer environment properly configured for your projects can be time-consuming and error-prone. Too often, the requirements are not
    clearly defined, are simply outdated, or make assumptions about the existing environment. Getting it slightly wrong can result in failures that are difficult
    to diagnose and could take days or weeks to discover. Working with multiple projects that have potentially conflicting requirements can make multi-tasking
    a chore. This talk will describe the criteria we can use to determine the effectiveness of a solution to these problems, apply those to historical techniques,
    and will present a deeper look at two modern solutions, GitHub Codespaces and Microsoft Dev Box.</p>
  speakers: [128]
  language: en
-
  id: 229
  title: "Cache friendly algorithm"
  description: >
    <p>I believe we all know that cache memory is a lot faster than main memory. Therefore, if we want performant code, we need to think about the memory.
    We need to think not only about the algorithms we are using, but also on how the data is laid out in the memory. However, most talks about the subject
    discuss the theory, and provide very simple examples, that are very far from real-life scenarios. In this talk I will discuss one complex case I had to optimize,
    which although it used relatively smart logic, performed badly. We will see how to find bottlenecks and how to resolve them, to get much better performance.</p>
  speakers: [129]
  language: en
-
  id: 98
  title: "Introduction to Smart Pointers and Why"
  description: >
    <p>Pointers are one of the most powerful tools in the C++ language available to programmers. Pointers allow sharing of resources, and for programmers
    to take control of the lifetime of their objects. However-- 'with great power comes great responsibility'. In this talk I am going to begin with how
    programmers can 'wrap' a raw pointer in a class to create a smart pointer that takes advantage of RAII to reclaim resources. I will then introduce
    in the standard library each of <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>. Beginners who have never seen these before
    will leave with concrete advice on where to use each of the following and for what scenarios where they previously had used raw pointers.
    Finally, at the end of the talk, I will give a brief insight into Smart pointer adaptors in C++23
    (<code>out_ptr_t</code>, <code>out_ptr</code>, <code>inout_ptr_t</code>, and <code>inout_ptr</code>).</p>
  speakers: [23]
  language: en
-
  id: 231
  title: "From the Command Line, to Make, to CMake, to Conan, to Artifactory, to Xray"
  description: >
    <p>This session examines the layers of tooling used to produce C/C++ applications and make developers’ lives easier.
    You'll see the big picture of how all these pieces fit together. Surveys say a major pain point facing C/C++ developers
    are long build times. One way to save time is to only re-build an artifact when a change occurs. Although the command line
    offers the precision of specifying what to build, doing this and tracking changes manually can quickly become a daunting and
    error-prone proposition. Make as a build system allows developers to specify and execute command line statements depending on
    what file changes are detected. However, these statements may be particular to one compiler or operating system. CMake provides
    the missing flexibility for a Makefile file. One CMake file can generate what’s needed for a variety of build systems, compilers,
    and operating systems. Another major pain point facing C/C++ developers is managing all the libraries needed by an application.
    Libraries provide the functionality programs need. But it gets tricky when libraries depend on other libraries that depend on other libraries
    in a spaghetti-like formation. Conan is a MIT-licensed, Open Source package manager for C and C++ development. Its goal is to alleviate this burden.
    ConanCenter, for example, features over 1000 recipes thanks to the work of awesome community members. The promise of a recipe is to untangle
    the spaghetti and list the dependencies for a given library. Conan packages may be stored in an Artifactory remote repository.
    Xray scans Artifactory for vulnerabilities.</p>
  speakers: [131]
  language: en
-
  id: 232
  title: "Repo Convergence: How we Migrated Our Cross-Platform Project from Multiple Repositories to a Mono Repo"
  description: >
    <p>The real case-study of how we migrated our c/c++ cross-platform project from multiple repositories to a single, converged, repository.
    We will describe the initial motivation for this change, detail the various challenges we encountered along the way and show which
    tools did we used to overcome those challenges. This presentation is valuable for anyone looking into similar transition but might
    be hesitating to get started.</p>
  speakers: [132]
  language: en
-
  id: 21
  title: "Keynote"
  description: >
    <p>To be published soon!</p>
  speakers: [10]
  language: en
-
  id: 002
  title: "Closing session"
  description: "TBD"
-
  id: 005
  title: "A lot of great C++ content!"
  description: "A lot of great C++ content! Sumbit yours at <a href='https://cfs.corecpp.org/'>https://cfs.corecpp.org/<a>"
-
  id: 006
  title: "More activities"
  description: "In construction"
  service: true
-
  id: 007
  title: "Meetup & Lightning Talks"
  description: "Stay tuned!"
  service: true
-
  id: 008
  title: "In construction"
  description: "More great C++ content!"
  service: true
-
  id: 099
  title: "Welcome to Core C++ 2022!"
  #place: "Weston::Auditorium"
  subtype: keynote
  service: true
-
  id: 101
  title: "Break"
  service: true
-
  id: 102
  title: "Lunch"
#  place: "Economics::Lobby"
  service: true
-
  id: 104
  title: "Updates"
  #place: "Weston::Auditorium"
  service: true
-
  id: 105
  title: "Closing Remarks"
  #place: "Weston::Auditorium"
  service: true
-
  id: 106
  title: "Registration and Coffee"
#  place: "Economics::Lobby"
  service: true
-
  id: 107
  title: "Coffee Break"
#  place: "Economics::Lobby"
  service: true
#  speakers: [30, 31]
